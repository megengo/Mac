#----------------------#
#-- Mac Core Library --#
#----------------------#
# Purpose: Core zsh functionality for Mac
# Usage: source mcl
#
# Glossary:
# ts0 - True, successful, 0, i.e., default return value for a successful evaluation
# ff1 - False, failure, 1, i.e., opposite of ts0
# prv - Previous return value

#----------------------#
#-- Global Constants --#
#----------------------#

readonly MCL_VERSION="0.0.0"

#---------------#
#-- Functions --#
#---------------#

#-- Chronicle --#
# Outputs all arguments prepended with a date time string. Chronicle messages
# have 3 fields, i.e. date, time, level.
#
# Date format: 8-digit date, 6 digit time
# date is 4 digit year, 2 digit month, 2 digit day
# time is 2 digit hour, 2 digit minute, 2 digit second
#
# Call the log level functions defined below instead of chronicle directly
mclChronicle(){
    readonly log="$(date '+%Y%m%d %H%M%S') $@"
    [ -n "$MCL_LOG" ] && tee -a "$MCL_LOG" <<< "$log" || echo "$log"
}

#-- Chronicle Log Levels --#
# Prepends a string representing one of four log levels to a chronicle message.
# These functions should be called directly instead of chronicle.
#
# Debug:
# The default for all acts performed. Because of the incredibly high quantity of
# logs this generates, this level should be excluded from scripts triggered by
# argument.
mclDebug(){ mclChronicle "Debug $@"; }
# Info:
# Generic status reporting messages
mclInfo(){ mclChronicle "Info $@"; }
# Warn:
# Harmful or otherwise particularly noteworthy messages which are not
# necessarily expected to correlate to a failure
mclWarn(){ mclChronicle "Warn $@"; }
# Error:
# Messages which necessarily correlate to a failure
mclError(){ mclChronicle "Error $@"; }

#-- Fail Messages --#
# Logs a message if the prv was not ts0
mclFDebug(){
    readonly previous="$?"
    readonly arguments=("-p" "$previous" "$@")
    mclFailChk "${arguments[@]}" && return 0
    mclDebug "$@" && return 1
}
mclFInfo(){
    readonly previous="$?"
    readonly arguments=("-p" "$previous" "$@")
    mclFailChk "${arguments[@]}" && return 0
    mclInfo "$@" && return 1
}
mclFWarn(){
    readonly previous="$?"
    readonly arguments=("-p" "$previous" "$@")
    mclFailChk "${arguments[@]}" && return 0
    mclWarn "$@" && return 1
}
mclFError(){
    readonly previous="$?"
    readonly arguments=("-p" "$previous" "$@")
    mclFailChk "${arguments[@]}" && return 0
    mclError "$@" && return 1
}

#-- Fail Check --#
# Compares the prv to ts0 or any other optional return value and returns ts0 if
# that comparison returns true. Otherwise, this function returns ff1.
#
# Options
#   -p <number>
#       Specifies the previous return value so that other functions may call
#       this one after the previous
#   -r <number>
#       Manual override from the default success value (0)
mclFailChk(){
    local previous="$?"
    local expected="0"
    while [ -n "$1" ]; do
        case "$1" in
            "-p")   shift
                    mclIsNum && previous="$1" ;;
            "-r")   shift
                    mclIsNum && expected="$1" ;;
            *)      break ;;
        esac
        shift
    done
    [ "$previous" = "$expected" ]
}

#-- Is Number --#
# Returns true if the argument is a whole number
mclIsNum(){ grep -E '^[0-9]{1,}$' <<< "$1" &> /dev/null; }